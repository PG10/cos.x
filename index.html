<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Selective Photorealistic Glow</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- 
        Standard Three.js Libraries using CDN links (r128) 
    -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <!-- Standard Example Loaders (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- POST-PROCESSING PASSES (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script> 
    
    <!-- SHADER FILES REQUIRED FOR THE COMPOSER CHAIN (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    
    <script>
        // --- FILE PATHS ---
        const BANDS_MODEL_PATH      = './bands.glb';
        const FEEDS_MODEL_PATH      = './feeds.glb';
        const GRIPPER_MODEL_PATH    = './gripper.glb';
        const HOLDER_MODEL_PATH     = './holder.glb';
        const LENS_MODEL_PATH       = './lens.glb';
        const SHADE_MODEL_PATH      = './shade.glb';
        const SINK_MODEL_PATH       = './sink.glb';    
        const SUSPENSION_MODEL_PATH = './suspension.glb';
        
        let scene, camera, renderer, controls;
        let bloomComposer, finalComposer;
        
        // --- SELECTIVE BLOOM SETUP ---
        const ENTIRE_SCENE = 0;
        const BLOOM_SCENE = 1;

        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        const materials = {};
        const darkMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
        // ------------------------------
        
        function init() {
            const INITIAL_CAMERA_Z = 50.0; 

            // 1. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Cineon Tone Mapping for soft highlights
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = 0.3; // Low exposure for white background
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            renderer.setClearColor(0xffffff); // White background
            document.body.appendChild(renderer.domElement);

            // 2. Setup Scene and Camera
            scene = new THREE.Scene();
            // High ambient light to illuminate non-glowing parts on a white background
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); 
            scene.add(ambientLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0.0, 10.0, INITIAL_CAMERA_Z); 
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.enableDamping = true;
            controls.update();
            
            // 4. Setup Composers (Bloom Effect)
            setupComposers();

            // 5. Load Assets
            loadHDRAndModels();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function setupComposers() {
            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.5,  // strength (lower for white background)
                0.3,  // radius (tighter glow)
                0.85   // threshold 
            );

            bloomComposer = new THREE.EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(renderScene);
            bloomComposer.addPass(bloomPass);

            const finalPass = new THREE.ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: null },
                        bloomTexture: { value: bloomComposer.renderTarget2.texture } 
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D baseTexture;
                        uniform sampler2D bloomTexture;
                        varying vec2 vUv;
                        void main() {
                            vec4 baseColor = texture2D( baseTexture, vUv );
                            vec4 bloomColor = texture2D( bloomTexture, vUv );
                            gl_FragColor = baseColor + (bloomColor * 1.0); 
                        }
                    `,
                    defines: {}
                }), "baseTexture"
            );
            finalPass.needsSwap = true;

            finalComposer = new THREE.EffectComposer(renderer);
            finalComposer.addPass(renderScene);
            finalComposer.addPass(finalPass);
        }

        function loadHDRAndModels() {
            new THREE.RGBELoader()
                .setPath('./') 
                .load('env.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; 
                    renderer.autoClear = false; 
                    // Lower environment map contribution to rely more on AmbientLight
                    scene.environmentIntensity = 0.1; 
                    loadAllModels();
                },
                undefined, 
                (error) => console.error("FATAL ERROR: Could not load 'env.hdr'. Check server path.", error)
            );
        }

        function loadAllModels() {
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('./draco/'); 
            
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            const modelPaths = {
                'sink': SINK_MODEL_PATH, 'shade': SHADE_MODEL_PATH, 'bands': BANDS_MODEL_PATH, 
                'feeds': FEEDS_MODEL_PATH, 'gripper': GRIPPER_MODEL_PATH, 'holder': HOLDER_MODEL_PATH, 
                'lens': LENS_MODEL_PATH, 'suspension': SUSPENSION_MODEL_PATH
            };

            const onModelLoaded = (gltf, modelName) => {
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        
                        let material = child.material;
                        
                        // Ensure it's a PBR material
                        if (modelName === 'shade' && !material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshPhysicalMaterial().copy(material);
                            child.material = material;
                        } else if (!material.isMeshStandardMaterial && !material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshStandardMaterial().copy(material);
                            child.material = material;
                        }

                        // --- APPLY FINAL PBR AND GLOW PROPERTIES ---
                        material.emissive.set(0x000000); // Base emissive reset
                        child.layers.set(ENTIRE_SCENE); 

                        if (modelName === 'shade') {
                            // TRANSLUCENT SHADE: MESHPHYSICALMATERIAL 
                            material.transmission = 0.8; 
                            material.thickness = 0.8; 
                            material.transparent = true;
                            material.side = THREE.DoubleSide; 
                            material.roughness = 0.9; 
                            material.metalness = 0.0;
                            material.color.set(0xffffff);
                            
                            // SHADE GLOW (Target for Bloom)
                            material.emissive.set(0xffeebb);
                            material.emissiveIntensity = 0.5; 
                            child.layers.enable(BLOOM_SCENE); 
                            
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS (Primary light source)
                            material.metalness = 0.1; material.roughness = 0.1; 
                            material.emissive.set(0xffeebb); 
                            material.emissiveIntensity = 20.0; 
                            child.layers.enable(BLOOM_SCENE); 

                        } else if (modelName === 'sink' || modelName === 'holder' || modelName === 'bands' || modelName === 'feeds') {
                            // CERAMIC/PLASTIC PARTS (Matte Off-White)
                            material.metalness = 0.0; // Non-metallic
                            material.roughness = 0.9; // Very rough/matte texture
                            // Using a very bright off-white to allow subtle shadow details to appear
                            material.color.set(0xf5f5f5); 
                            
                        } else if (modelName === 'gripper' || modelName === 'suspension') {
                            // METAL PARTS (Dark Gray Chrome)
                            material.metalness = 0.9; // Highly metallic
                            material.roughness = 0.5; // Slightly rougher metal
                            material.color.set(0x444444); // Dark gray color
                        }
                        
                        child.material.needsUpdate = true;
                        // --- END MATERIAL CUSTOMIZATION ---
                    }
                });
                
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(1.0, 1.0, 1.0);
                scene.add(loadedModel);
            };
            
            // Load all models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    undefined, 
                    (error) => console.error(`Error loading ${modelName}:`, error)
                );
            });
        }
        
        // --- SELECTIVE BLOOM RENDER UTILITIES ---
        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }
        // ---------------------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomComposer.setSize(window.innerWidth, window.innerHeight); 
            finalComposer.setSize(window.innerWidth, window.innerHeight); 
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); 
            
            // 1. Render the scene, but make all non-glowing objects black
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();

            // 2. Restore all original materials
            scene.traverse(restoreMaterial);
            
            // 3. Render the final combined scene (original objects + bloom)
            finalComposer.render();
        }

        init();
    </script>
</body>
</html>
