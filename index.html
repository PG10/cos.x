<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Self-Illuminated Glow</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #controls label {
            display: block;
            margin: 5px 0;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading LED Fixture...</div>
    <div id="controls">
        <label>Bloom Strength: <input type="range" id="bloomStrength" min="0" max="10" step="0.1" value="5.0"></label>
        <label>Emission Power: <input type="range" id="emissionIntensity" min="0" max="100" step="1" value="40"></label>
        <label>Exposure: <input type="range" id="exposure" min="0" max="3" step="0.1" value="1.0"></label>
    </div>

    <!-- Reliable Three.js CDN URLs for r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/RGBELoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/DRACOLoader.js"></script>
    
    <script>
        // --- SCENE CONFIGURATION PARAMETERS ---
        const CONFIG = {
            // RENDERER & ENVIRONMENT
            TONE_MAPPING_EXPOSURE: 1.0,          
            BACKGROUND_COLOR: 0x111111,          
            HDR_ENVIRONMENT_INTENSITY: 0.7,      
            
            // MATERIAL COLORS
            CERAMIC_COLOR: 0xe8e8e8,             
            METAL_COLOR: 0x444444,               
            LENS_EMISSIVE_COLOR: 0xffd8b0,       
            SHADE_BASE_COLOR: 0xffffff,          
            
            // MATERIAL PROPERTIES
            CERAMIC_ROUGHNESS: 1.0,              
            SHADE_TRANSMISSION: 0.9,             
            
            // LIGHT EMISSION INTENSITIES
            LENS_EMISSIVE_INTENSITY: 40.0,       
            SHADE_EMISSIVE_INTENSITY: 0.0,       
            
            // BLOOM SETTINGS
            BLOOM_STRENGTH: 5.0,                 
            BLOOM_RADIUS: 0.5,                   
            BLOOM_THRESHOLD: 0.9                 
        };

        // --- FILE PATHS (Restored from your original) ---
        const BANDS_MODEL_PATH      = './bands.glb';
        const FEEDS_MODEL_PATH      = './feeds.glb';
        const GRIPPER_MODEL_PATH    = './gripper.glb';
        const HOLDER_MODEL_PATH     = './holder.glb';
        const LENS_MODEL_PATH       = './lens.glb';
        const SHADE_MODEL_PATH      = './shade.glb';
        const SINK_MODEL_PATH       = './sink.glb';    
        const SUSPENSION_MODEL_PATH = './suspension.glb';
        
        let scene, camera, renderer, controls;
        let lensObjects = [];
        let shadeObjects = [];
        let modelsLoaded = 0;
        const totalModels = 8;
        
        // Custom bloom implementation (avoiding problematic post-processing CDN)
        let bloomRenderTarget, baseRenderTarget;
        let bloomMaterial, compositeMaterial;
        let bloomScene, darkMaterial;
        let bloomLayer = new THREE.Layers();
        let materials = {};
        
        // Set bloom layer
        bloomLayer.set(1);
        
        function init() {
            // Check if Three.js loaded properly
            if (typeof THREE === 'undefined') {
                console.error('Three.js failed to load');
                document.getElementById('loading').innerHTML = 'Error: Three.js failed to load';
                return;
            }

            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = CONFIG.TONE_MAPPING_EXPOSURE; 
            renderer.outputEncoding = THREE.sRGBEncoding; 
            
            renderer.setClearColor(CONFIG.BACKGROUND_COLOR); 
            document.body.appendChild(renderer.domElement);

            // Setup Scene and Camera
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0.0, 10.0, 50.0); 
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.enableDamping = true;
            controls.update();
            
            // Setup custom bloom effect
            setupCustomBloom();
            
            // Load HDR and Models
            loadHDRAndModels();
            
            // Setup UI controls
            setupUIControls();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function setupCustomBloom() {
            // Create render targets
            bloomRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
            baseRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
            
            // Dark material for non-bloom objects
            darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            // Bloom extraction material
            bloomMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    threshold: { value: CONFIG.BLOOM_THRESHOLD },
                    strength: { value: CONFIG.BLOOM_STRENGTH }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float threshold;
                    uniform float strength;
                    varying vec2 vUv;
                    
                    vec3 luma = vec3(0.299, 0.587, 0.114);
                    
                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        float brightness = dot(color.rgb, luma);
                        
                        float contribution = max(0.0, brightness - threshold);
                        contribution /= max(brightness, 0.00001);
                        
                        gl_FragColor = color * contribution * strength;
                    }
                `
            });
            
            // Composite material
            compositeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: bloomRenderTarget.texture }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D baseTexture;
                    uniform sampler2D bloomTexture;
                    varying vec2 vUv;
                    void main() {
                        vec4 base = texture2D(baseTexture, vUv);
                        vec4 bloom = texture2D(bloomTexture, vUv);
                        gl_FragColor = base + bloom * 0.8;
                    }
                `
            });
        }

        function loadHDRAndModels() {
            // Loading HDR texture
            new THREE.RGBELoader()
                .setPath('./') 
                .load('env.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; 
                    scene.environmentIntensity = CONFIG.HDR_ENVIRONMENT_INTENSITY; 
                    loadAllModels();
                },
                undefined, 
                (error) => {
                     console.warn("Could not load 'env.hdr'. Proceeding without environment map.", error);
                     loadAllModels();
                }
            );
        }

        function loadAllModels() {
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('./draco/'); 
            
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            const modelPaths = {
                'sink': SINK_MODEL_PATH, 'shade': SHADE_MODEL_PATH, 'bands': BANDS_MODEL_PATH, 
                'feeds': FEEDS_MODEL_PATH, 'gripper': GRIPPER_MODEL_PATH, 'holder': HOLDER_MODEL_PATH, 
                'lens': LENS_MODEL_PATH, 'suspension': SUSPENSION_MODEL_PATH
            };

            const isCeramicPart = (name) => 
                name === 'sink' || name === 'holder' || name === 'bands' || name === 'feeds';
            
            const onModelLoaded = (gltf, modelName) => {
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        let material = child.material;
                        
                        // Ensure material is MeshPhysicalMaterial for PBR and transmission
                        if (!material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshPhysicalMaterial().copy(material);
                            child.material = material;
                        }

                        // Reset emissive
                        material.emissive.set(0x000000); 
                        child.layers.set(0); // Default layer
                        
                        if (modelName === 'shade') {
                            // TRANSLUCENT SHADE
                            material.transmission = CONFIG.SHADE_TRANSMISSION; 
                            material.thickness = 1.0; 
                            material.transparent = true;
                            material.side = THREE.DoubleSide; 
                            material.roughness = 0.9; 
                            material.metalness = 0.0;
                            material.color.set(CONFIG.SHADE_BASE_COLOR); 
                            material.emissiveIntensity = CONFIG.SHADE_EMISSIVE_INTENSITY; 
                            
                            shadeObjects.push(child);
                            
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS: The primary light source
                            material.metalness = 0.0; 
                            material.roughness = 0.0;
                            material.color.set(0xffffff);
                            material.emissive.set(CONFIG.LENS_EMISSIVE_COLOR); 
                            material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY; 
                            child.layers.enable(1); // Enable bloom layer
                            
                            lensObjects.push(child);

                        } else if (isCeramicPart(modelName)) {
                            // CERAMIC PARTS
                            material.metalness = 0.0; 
                            material.roughness = CONFIG.CERAMIC_ROUGHNESS; 
                            material.color.set(CONFIG.CERAMIC_COLOR); 
                            
                        } else if (modelName === 'gripper' || modelName === 'suspension') {
                            // METAL PARTS
                            material.metalness = 0.9; 
                            material.roughness = 0.5; 
                            material.color.set(CONFIG.METAL_COLOR); 
                        }
                        
                        child.material.needsUpdate = true;
                    }
                });
                
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(1.0, 1.0, 1.0);
                scene.add(loadedModel);
                
                // Update loading progress
                modelsLoaded++;
                if (modelsLoaded === totalModels) {
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            // Load all your original models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    undefined, 
                    (error) => {
                        console.error(`Error loading ${modelName}:`, error);
                        modelsLoaded++; // Still increment to prevent hanging
                        if (modelsLoaded === totalModels) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    }
                );
            });
        }
        
        function setupUIControls() {
            const bloomSlider = document.getElementById('bloomStrength');
            const emissionSlider = document.getElementById('emissionIntensity');
            const exposureSlider = document.getElementById('exposure');
            
            bloomSlider.addEventListener('input', (e) => {
                CONFIG.BLOOM_STRENGTH = parseFloat(e.target.value);
                bloomMaterial.uniforms.strength.value = CONFIG.BLOOM_STRENGTH;
            });
            
            emissionSlider.addEventListener('input', (e) => {
                CONFIG.LENS_EMISSIVE_INTENSITY = parseFloat(e.target.value);
                lensObjects.forEach(lens => {
                    lens.material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY;
                });
            });
            
            exposureSlider.addEventListener('input', (e) => {
                renderer.toneMappingExposure = parseFloat(e.target.value);
            });
        }
        
        // Selective bloom render utilities
        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (bloomRenderTarget && baseRenderTarget) {
                bloomRenderTarget.setSize(window.innerWidth, window.innerHeight);
                baseRenderTarget.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); 
            
            // Custom bloom rendering
            if (bloomRenderTarget && baseRenderTarget) {
                // 1. Render scene normally to base target
                renderer.setRenderTarget(baseRenderTarget);
                renderer.render(scene, camera);
                
                // 2. Render only emissive objects for bloom
                scene.traverse(darkenNonBloomed);
                renderer.setRenderTarget(bloomRenderTarget);
                renderer.render(scene, camera);
                scene.traverse(restoreMaterial);
                
                // 3. Composite final result to screen
                renderer.setRenderTarget(null);
                
                // Use a simple additive blend by rendering both targets
                renderer.render(scene, camera);
                
                // Add bloom on top (simplified approach)
                const bloomQuad = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    new THREE.ShaderMaterial({
                        uniforms: {
                            tDiffuse: { value: bloomRenderTarget.texture },
                            strength: { value: 0.8 }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D tDiffuse;
                            uniform float strength;
                            varying vec2 vUv;
                            void main() {
                                vec4 bloom = texture2D(tDiffuse, vUv);
                                gl_FragColor = bloom * strength;
                            }
                        `,
                        blending: THREE.AdditiveBlending,
                        transparent: true
                    })
                );
                
                // Render bloom overlay
                const orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const orthoScene = new THREE.Scene();
                orthoScene.add(bloomQuad);
                renderer.render(orthoScene, orthoCam);
                
            } else {
                // Fallback rendering
                renderer.render(scene, camera);
            }
        }

        // Initialize when page loads (with delay to ensure scripts load)
        function initWhenReady() {
            if (typeof THREE !== 'undefined' && THREE.GLTFLoader && THREE.RGBELoader && THREE.OrbitControls) {
                init();
            } else {
                console.log('Waiting for Three.js to load...');
                setTimeout(initWhenReady, 100);
            }
        }
        
        window.addEventListener('load', initWhenReady);
    </script>
</body>
</html>