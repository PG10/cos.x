<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Self-Illuminated Glow</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #111;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #controls label {
            display: block;
            margin: 5px 0;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading LED Fixture...</div>
    <div id="controls">
        <label>Bloom Intensity: <input type="range" id="bloomStrength" min="0" max="10" step="0.1" value="3.0"></label>
        <label>Emission Power: <input type="range" id="emissionIntensity" min="0" max="100" step="1" value="40"></label>
        <label>Warm/Cool: <input type="range" id="colorTemp" min="2700" max="6500" step="100" value="3000"></label>
    </div>
    
    <!-- Use the correct CDN for Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- SCENE CONFIGURATION PARAMETERS ---
        const CONFIG = {
            TONE_MAPPING_EXPOSURE: 1.0,          
            BACKGROUND_COLOR: 0x0a0a0a,          
            
            // MATERIAL COLORS
            CERAMIC_COLOR: 0xe8e8e8,             
            METAL_COLOR: 0x444444,               
            LENS_EMISSIVE_COLOR: 0xffd8b0,       
            SHADE_BASE_COLOR: 0xffffff,          
            
            // MATERIAL PROPERTIES
            CERAMIC_ROUGHNESS: 0.8,              
            SHADE_TRANSMISSION: 0.85,             
            
            // LIGHT EMISSION INTENSITIES
            LENS_EMISSIVE_INTENSITY: 40.0,       
            SHADE_EMISSIVE_INTENSITY: 0.0,       
            
            // BLOOM SETTINGS
            BLOOM_STRENGTH: 3.0,                 
            BLOOM_RADIUS: 0.8,                   
            BLOOM_THRESHOLD: 0.85                
        };

        let scene, camera, renderer, controls;
        let lensObjects = [];
        let shadeObjects = [];
        let isLoading = true;
        
        // Simple bloom effect using custom shaders
        let bloomRenderTarget;
        let bloomMaterial;
        let compositeMaterial;
        let bloomScene;
        let finalScene;
        
        function init() {
            // Remove loading indicator
            document.getElementById('loading').style.display = 'none';
            
            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = CONFIG.TONE_MAPPING_EXPOSURE;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setClearColor(CONFIG.BACKGROUND_COLOR);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Setup Scene and Camera
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);
            
            // Simple orbit controls implementation
            setupControls();
            
            // Setup custom bloom effect
            setupBloomEffect();
            
            // Add environment lighting
            setupLighting();
            
            // Create procedural LED fixture
            createLEDFixture();
            
            // Setup UI controls
            setupUIControls();

            window.addEventListener('resize', onWindowResize, false);
            animate();
            isLoading = false;
        }
        
        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let rotationX = 0, rotationY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                targetY += deltaX * 0.01;
                targetX += deltaY * 0.01;
                targetX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetX));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.05;
                camera.position.z = Math.max(10, Math.min(100, camera.position.z));
            });
            
            // Smooth rotation update
            function updateControls() {
                rotationX += (targetX - rotationX) * 0.1;
                rotationY += (targetY - rotationY) * 0.1;
                
                const radius = camera.position.length();
                camera.position.x = radius * Math.sin(rotationY) * Math.cos(rotationX);
                camera.position.y = radius * Math.sin(rotationX);
                camera.position.z = radius * Math.cos(rotationY) * Math.cos(rotationX);
                camera.lookAt(0, 0, 0);
            }
            
            controls = { update: updateControls };
        }
        
        function setupBloomEffect() {
            // Create render targets for bloom effect
            bloomRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth, 
                window.innerHeight,
                {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                }
            );
            
            // Bloom extraction shader
            bloomMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    threshold: { value: CONFIG.BLOOM_THRESHOLD },
                    strength: { value: CONFIG.BLOOM_STRENGTH }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float threshold;
                    uniform float strength;
                    varying vec2 vUv;
                    
                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        float brightness = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        
                        if(brightness > threshold) {
                            gl_FragColor = color * strength;
                        } else {
                            gl_FragColor = vec4(0.0);
                        }
                    }
                `
            });
            
            // Composite shader
            compositeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: null },
                    bloomStrength: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D baseTexture;
                    uniform sampler2D bloomTexture;
                    uniform float bloomStrength;
                    varying vec2 vUv;
                    
                    void main() {
                        vec4 base = texture2D(baseTexture, vUv);
                        vec4 bloom = texture2D(bloomTexture, vUv);
                        gl_FragColor = base + bloom * bloomStrength;
                    }
                `
            });
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Add some fill lights
            const fillLight1 = new THREE.PointLight(0x4488ff, 0.3, 50);
            fillLight1.position.set(-20, 10, 20);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.PointLight(0xff8844, 0.3, 50);
            fillLight2.position.set(20, 5, -15);
            scene.add(fillLight2);
        }
        
        function createLEDFixture() {
            // Create fixture components procedurally
            
            // Main housing (ceramic sink)
            const housingGeometry = new THREE.CylinderGeometry(8, 10, 4, 32);
            const housingMaterial = new THREE.MeshPhysicalMaterial({
                color: CONFIG.CERAMIC_COLOR,
                roughness: CONFIG.CERAMIC_ROUGHNESS,
                metalness: 0.0
            });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.position.y = -2;
            housing.receiveShadow = true;
            scene.add(housing);
            
            // LED lens array (main light source)
            const lensGroup = new THREE.Group();
            const lensGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            
            // Create LED array pattern
            const positions = [
                [0, 0], // Center
                [-2.5, 0], [2.5, 0], [0, -2.5], [0, 2.5], // Cross
                [-1.8, -1.8], [1.8, -1.8], [-1.8, 1.8], [1.8, 1.8] // Corners
            ];
            
            positions.forEach(([x, z]) => {
                const lensMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    emissive: CONFIG.LENS_EMISSIVE_COLOR,
                    emissiveIntensity: CONFIG.LENS_EMISSIVE_INTENSITY,
                    roughness: 0.1,
                    metalness: 0.0
                });
                
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                lens.position.set(x, 0, z);
                lensObjects.push(lens);
                lensGroup.add(lens);
            });
            
            scene.add(lensGroup);
            
            // Translucent shade
            const shadeGeometry = new THREE.ConeGeometry(12, 15, 32, 1, true);
            const shadeMaterial = new THREE.MeshPhysicalMaterial({
                color: CONFIG.SHADE_BASE_COLOR,
                transparent: true,
                transmission: CONFIG.SHADE_TRANSMISSION,
                roughness: 0.1,
                metalness: 0.0,
                side: THREE.DoubleSide,
                thickness: 1.0
            });
            const shade = new THREE.Mesh(shadeGeometry, shadeMaterial);
            shade.position.y = 7.5;
            shadeObjects.push(shade);
            scene.add(shade);
            
            // Metal suspension system
            const suspensionGeometry = new THREE.CylinderGeometry(0.3, 0.3, 20, 8);
            const suspensionMaterial = new THREE.MeshPhysicalMaterial({
                color: CONFIG.METAL_COLOR,
                roughness: 0.3,
                metalness: 0.9
            });
            const suspension = new THREE.Mesh(suspensionGeometry, suspensionMaterial);
            suspension.position.y = 20;
            suspension.castShadow = true;
            scene.add(suspension);
            
            // Mounting hardware
            const mountGeometry = new THREE.BoxGeometry(2, 1, 2);
            const mountMaterial = new THREE.MeshPhysicalMaterial({
                color: CONFIG.METAL_COLOR,
                roughness: 0.4,
                metalness: 0.8
            });
            const mount = new THREE.Mesh(mountGeometry, mountMaterial);
            mount.position.y = 30;
            mount.castShadow = true;
            scene.add(mount);
            
            // Decorative bands
            for (let i = 0; i < 3; i++) {
                const bandGeometry = new THREE.TorusGeometry(9 + i * 0.5, 0.2, 8, 32);
                const bandMaterial = new THREE.MeshPhysicalMaterial({
                    color: CONFIG.CERAMIC_COLOR,
                    roughness: 0.6,
                    metalness: 0.1
                });
                const band = new THREE.Mesh(bandGeometry, bandMaterial);
                band.position.y = -1 + i * 0.5;
                scene.add(band);
            }
        }
        
        function setupUIControls() {
            const bloomSlider = document.getElementById('bloomStrength');
            const emissionSlider = document.getElementById('emissionIntensity');
            const colorTempSlider = document.getElementById('colorTemp');
            
            bloomSlider.addEventListener('input', (e) => {
                CONFIG.BLOOM_STRENGTH = parseFloat(e.target.value);
                if (bloomMaterial) {
                    bloomMaterial.uniforms.strength.value = CONFIG.BLOOM_STRENGTH;
                }
            });
            
            emissionSlider.addEventListener('input', (e) => {
                CONFIG.LENS_EMISSIVE_INTENSITY = parseFloat(e.target.value);
                lensObjects.forEach(lens => {
                    lens.material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY;
                });
            });
            
            colorTempSlider.addEventListener('input', (e) => {
                const temp = parseInt(e.target.value);
                const color = temperatureToColor(temp);
                CONFIG.LENS_EMISSIVE_COLOR = color;
                lensObjects.forEach(lens => {
                    lens.material.emissive.setHex(color);
                });
            });
        }
        
        function temperatureToColor(temp) {
            // Convert color temperature to RGB hex
            temp = temp / 100;
            let red, green, blue;
            
            if (temp <= 66) {
                red = 255;
                green = temp;
                green = 99.4708025861 * Math.log(green) - 161.1195681661;
                if (temp >= 19) {
                    blue = temp - 10;
                    blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
                } else {
                    blue = 0;
                }
            } else {
                red = temp - 60;
                red = 329.698727446 * Math.pow(red, -0.1332047592);
                green = temp - 60;
                green = 288.1221695283 * Math.pow(green, -0.0755148492);
                blue = 255;
            }
            
            red = Math.max(0, Math.min(255, red));
            green = Math.max(0, Math.min(255, green));
            blue = Math.max(0, Math.min(255, blue));
            
            return (Math.round(red) << 16) + (Math.round(green) << 8) + Math.round(blue);
        }
        
        function renderBloom() {
            // Simple bloom approximation using glow
            const originalMaterials = [];
            
            // Store original materials and apply emissive-only rendering
            scene.traverse((obj) => {
                if (obj.isMesh) {
                    originalMaterials.push({
                        obj: obj,
                        material: obj.material
                    });
                    
                    // Only show emissive objects
                    if (obj.material.emissiveIntensity > 0) {
                        obj.material = new THREE.MeshBasicMaterial({
                            color: obj.material.emissive,
                            transparent: true,
                            opacity: Math.min(1.0, obj.material.emissiveIntensity / 20)
                        });
                    } else {
                        obj.visible = false;
                    }
                }
            });
            
            // Render to bloom target
            renderer.setRenderTarget(bloomRenderTarget);
            renderer.render(scene, camera);
            
            // Restore materials
            originalMaterials.forEach(({obj, material}) => {
                obj.material = material;
                obj.visible = true;
            });
            
            renderer.setRenderTarget(null);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (bloomRenderTarget) {
                bloomRenderTarget.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) controls.update();
            
            // Add subtle animation to the fixture
            if (!isLoading) {
                const time = Date.now() * 0.001;
                
                // Gentle swaying motion
                scene.rotation.y = Math.sin(time * 0.3) * 0.02;
                
                // Subtle pulsing of LED intensity
                const pulse = 1.0 + Math.sin(time * 2) * 0.05;
                lensObjects.forEach(lens => {
                    lens.material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY * pulse;
                });
            }
            
            // Render with simple bloom effect
            renderBloom();
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>