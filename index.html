<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Self-Illuminated Glow</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        canvas { display: block; }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #controls label {
            display: block;
            margin: 5px 0;
        }
        #controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading LED Fixture...</div>
    <div id="controls" style="display: none;">
        <label>Bloom Strength: <input type="range" id="bloomStrength" min="0" max="10" step="0.1" value="5.0"></label>
        <label>Emission Power: <input type="range" id="emissionIntensity" min="0" max="100" step="1" value="40"></label>
        <label>Exposure: <input type="range" id="exposure" min="0" max="3" step="0.1" value="1.0"></label>
    </style>
    </div>

    <!-- Local Three.js files - no CDN dependency -->
    <script type="importmap">
    {
        "imports": {
            "three": "./js/three.module.js",
            "three/addons/": "./js/addons/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // Update loading status
        document.getElementById('loading').textContent = 'Initializing LED Fixture...';

        // --- SCENE CONFIGURATION PARAMETERS ---
        const CONFIG = {
            // RENDERER & ENVIRONMENT
            TONE_MAPPING_EXPOSURE: 1.0,          
            BACKGROUND_COLOR: 0x111111,          
            HDR_ENVIRONMENT_INTENSITY: 0.7,      
            
            // MATERIAL COLORS
            CERAMIC_COLOR: 0xe8e8e8,             
            METAL_COLOR: 0x444444,               
            LENS_EMISSIVE_COLOR: 0xffd8b0,       
            SHADE_BASE_COLOR: 0xffffff,          
            
            // MATERIAL PROPERTIES
            CERAMIC_ROUGHNESS: 1.0,              
            SHADE_TRANSMISSION: 0.9,             
            
            // LIGHT EMISSION INTENSITIES
            LENS_EMISSIVE_INTENSITY: 40.0,       
            SHADE_EMISSIVE_INTENSITY: 0.0,       
            
            // BLOOM SETTINGS
            BLOOM_STRENGTH: 5.0,                 
            BLOOM_RADIUS: 0.5,                   
            BLOOM_THRESHOLD: 0.9                 
        };

        // --- FILE PATHS (Your original GLB models) ---
        const BANDS_MODEL_PATH      = './bands.glb';
        const FEEDS_MODEL_PATH      = './feeds.glb';
        const GRIPPER_MODEL_PATH    = './gripper.glb';
        const HOLDER_MODEL_PATH     = './holder.glb';
        const LENS_MODEL_PATH       = './lens.glb';
        const SHADE_MODEL_PATH      = './shade.glb';
        const SINK_MODEL_PATH       = './sink.glb';    
        const SUSPENSION_MODEL_PATH = './suspension.glb';
        
        let scene, camera, renderer, controls;
        let lensObjects = [];
        let shadeObjects = [];
        let modelsLoaded = 0;
        const totalModels = 8;
        
        // Bloom effect variables
        let bloomRenderTarget;
        let bloomMaterial;
        let darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        let bloomLayer = new THREE.Layers();
        let materials = {};
        
        // Set bloom layer
        bloomLayer.set(1);
        
        function init() {
            console.log('Initializing LED Fixture...');
            
            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = CONFIG.TONE_MAPPING_EXPOSURE; 
            renderer.outputEncoding = THREE.sRGBEncoding; 
            
            renderer.setClearColor(CONFIG.BACKGROUND_COLOR); 
            document.body.appendChild(renderer.domElement);

            // Setup Scene and Camera
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0.0, 10.0, 50.0); 
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.enableDamping = true;
            controls.update();
            
            // Setup bloom effect
            setupBloomEffect();
            
            // Add basic lighting as fallback
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Load HDR and Models
            loadHDRAndModels();
            
            // Setup UI controls
            setupUIControls();

            window.addEventListener('resize', onWindowResize, false);
            animate();
            
            // Show controls
            document.getElementById('controls').style.display = 'block';
        }
        
        function setupBloomEffect() {
            // Create render target for bloom
            bloomRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth, 
                window.innerHeight,
                {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                }
            );
            
            // Simple bloom shader
            bloomMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    strength: { value: CONFIG.BLOOM_STRENGTH }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float strength;
                    varying vec2 vUv;
                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);
                        gl_FragColor = color * strength;
                    }
                `,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
        }

        function loadHDRAndModels() {
            // Try to load HDR environment
            const rgbeLoader = new RGBELoader();
            rgbeLoader.setPath('./');
            rgbeLoader.load('env.hdr', 
                function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                    scene.environmentIntensity = CONFIG.HDR_ENVIRONMENT_INTENSITY;
                    console.log('HDR environment loaded successfully');
                },
                undefined,
                function (error) {
                    console.warn('Could not load HDR environment:', error);
                }
            );
            
            // Load all models
            loadAllModels();
        }

        function loadAllModels() {
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('./draco/'); 
            
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            const modelPaths = {
                'sink': SINK_MODEL_PATH, 
                'shade': SHADE_MODEL_PATH, 
                'bands': BANDS_MODEL_PATH, 
                'feeds': FEEDS_MODEL_PATH, 
                'gripper': GRIPPER_MODEL_PATH, 
                'holder': HOLDER_MODEL_PATH, 
                'lens': LENS_MODEL_PATH, 
                'suspension': SUSPENSION_MODEL_PATH
            };

            const isCeramicPart = (name) => 
                name === 'sink' || name === 'holder' || name === 'bands' || name === 'feeds';
            
            const onModelLoaded = (gltf, modelName) => {
                console.log(`Loading model: ${modelName}`);
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        let material = child.material;
                        
                        // Ensure material is MeshPhysicalMaterial for PBR
                        if (!material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshPhysicalMaterial();
                            if (child.material.map) material.map = child.material.map;
                            if (child.material.color) material.color = child.material.color;
                            child.material = material;
                        }

                        // Reset emissive
                        material.emissive.set(0x000000); 
                        child.layers.set(0); // Default layer
                        
                        if (modelName === 'shade') {
                            // TRANSLUCENT SHADE
                            material.transmission = CONFIG.SHADE_TRANSMISSION; 
                            material.thickness = 1.0; 
                            material.transparent = true;
                            material.side = THREE.DoubleSide; 
                            material.roughness = 0.9; 
                            material.metalness = 0.0;
                            material.color.set(CONFIG.SHADE_BASE_COLOR); 
                            material.emissiveIntensity = CONFIG.SHADE_EMISSIVE_INTENSITY; 
                            
                            shadeObjects.push(child);
                            
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS: The primary light source
                            material.metalness = 0.0; 
                            material.roughness = 0.0;
                            material.color.set(0xffffff);
                            material.emissive.set(CONFIG.LENS_EMISSIVE_COLOR); 
                            material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY; 
                            child.layers.enable(1); // Enable bloom layer
                            
                            lensObjects.push(child);

                        } else if (isCeramicPart(modelName)) {
                            // CERAMIC PARTS
                            material.metalness = 0.0; 
                            material.roughness = CONFIG.CERAMIC_ROUGHNESS; 
                            material.color.set(CONFIG.CERAMIC_COLOR); 
                            
                        } else if (modelName === 'gripper' || modelName === 'suspension') {
                            // METAL PARTS
                            material.metalness = 0.9; 
                            material.roughness = 0.5; 
                            material.color.set(CONFIG.METAL_COLOR); 
                        }
                        
                        child.material.needsUpdate = true;
                    }
                });
                
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(1.0, 1.0, 1.0);
                scene.add(loadedModel);
                
                // Update loading progress
                modelsLoaded++;
                document.getElementById('loading').textContent = `Loading models... ${modelsLoaded}/${totalModels}`;
                
                if (modelsLoaded === totalModels) {
                    document.getElementById('loading').style.display = 'none';
                    console.log('All models loaded successfully');
                }
            };
            
            // Load all your original models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    (progress) => {
                        console.log(`Loading ${modelName}: ${(progress.loaded / progress.total * 100)}%`);
                    },
                    (error) => {
                        console.error(`Error loading ${modelName}:`, error);
                        modelsLoaded++; // Still increment to prevent hanging
                        if (modelsLoaded === totalModels) {
                            document.getElementById('loading').style.display = 'none';
                        }
                    }
                );
            });
        }
        
        function setupUIControls() {
            const bloomSlider = document.getElementById('bloomStrength');
            const emissionSlider = document.getElementById('emissionIntensity');
            const exposureSlider = document.getElementById('exposure');
            
            bloomSlider.addEventListener('input', (e) => {
                CONFIG.BLOOM_STRENGTH = parseFloat(e.target.value);
                if (bloomMaterial) {
                    bloomMaterial.uniforms.strength.value = CONFIG.BLOOM_STRENGTH;
                }
            });
            
            emissionSlider.addEventListener('input', (e) => {
                CONFIG.LENS_EMISSIVE_INTENSITY = parseFloat(e.target.value);
                lensObjects.forEach(lens => {
                    lens.material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY;
                });
            });
            
            exposureSlider.addEventListener('input', (e) => {
                renderer.toneMappingExposure = parseFloat(e.target.value);
            });
        }
        
        // Selective bloom utilities
        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (bloomRenderTarget) {
                bloomRenderTarget.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) controls.update(); 
            
            // Render scene with bloom effect
            if (bloomRenderTarget && lensObjects.length > 0) {
                // 1. Render only emissive objects to bloom target
                scene.traverse(darkenNonBloomed);
                renderer.setRenderTarget(bloomRenderTarget);
                renderer.render(scene, camera);
                scene.traverse(restoreMaterial);
                
                // 2. Render normal scene to screen
                renderer.setRenderTarget(null);
                renderer.render(scene, camera);
                
                // 3. Add bloom on top (simplified)
                const bloomQuad = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    bloomMaterial
                );
                bloomMaterial.uniforms.tDiffuse.value = bloomRenderTarget.texture;
                
                const orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const orthoScene = new THREE.Scene();
                orthoScene.add(bloomQuad);
                renderer.render(orthoScene, orthoCam);
                
            } else {
                // Fallback rendering
                renderer.render(scene, camera);
            }
        }

        // Start initialization
        init();

    </script>
</body>
</html>