<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="./js/three.min.js"></script>
    <script src="./js/GLTFLoader.js"></script>
    <script src="./js/RGBELoader.js"></script>
    <script src="./js/DRACOLoader.js"></script>
    <script src="./js/OrbitControls.js"></script>

    <script>
        // --- FILE PATHS (All 8 Components) ---
        const BANDS_MODEL_PATH      = '/cos.x/bands.glb';
        const FEEDS_MODEL_PATH      = '/cos.x/feeds.glb';
        const GRIPPER_MODEL_PATH    = '/cos.x/gripper.glb';
        const HOLDER_MODEL_PATH     = '/cos.x/holder.glb';
        const LENS_MODEL_PATH       = '/cos.x/lens.glb';
        const SHADE_MODEL_PATH      = '/cos.x/shade.glb';
        const SINK_MODEL_PATH       = '/cos.x/sink.glb';    
        const SUSPENSION_MODEL_PATH = '/cos.x/suspension.glb';
        
        let scene, camera, renderer, controls;
        let models = {}; 

        function init() {
            // --- EASY VIEW ADJUSTMENT VARIABLES ---
            const INITIAL_CAMERA_Z = 50.0; 
            const MIN_ZOOM_DISTANCE = 1.0;  
            const MAX_ZOOM_DISTANCE = 500.0; 
            // --------------------------------------

            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            renderer.setClearColor(0xffffff); 
            document.body.appendChild(renderer.domElement);

            // Setup Scene and Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            
            camera.position.set(0.0, 10.0, INITIAL_CAMERA_Z); 
            
            // OrbitControls Setup
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.minDistance = MIN_ZOOM_DISTANCE; 
            controls.maxDistance = MAX_ZOOM_DISTANCE; 
            controls.enableDamping = true;
            controls.update();

            loadHDRAndModels();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function loadHDRAndModels() {
            // Load the HDR Environment Map - Using the correct relative path './'
            new THREE.RGBELoader()
                .setPath('./') 
                .load('env.hdr', function (texture) {
                    
                    texture.mapping = THREE.EquirectangularReflectionMapping;

                    scene.environment = texture;

                    console.log("HDR Environment Map 'env.hdr' loaded successfully.");

                    loadAllModels();
                },
                (xhr) => console.log(((xhr.loaded / xhr.total) * 100).toFixed(0) + '% loaded HDR'),
                (error) => console.error("FATAL ERROR: Could not load 'env.hdr'. Please check your local server's root path.", error)
            );
        }

        function loadAllModels() {
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('/cos.x/draco/'); 
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            let modelsLoaded = 0;
            const totalModels = 8;
            const modelPaths = {
                'sink': SINK_MODEL_PATH,
                'shade': SHADE_MODEL_PATH,
                'bands': BANDS_MODEL_PATH,
                'feeds': FEEDS_MODEL_PATH,
                'gripper': GRIPPER_MODEL_PATH,
                'holder': HOLDER_MODEL_PATH,
                'lens': LENS_MODEL_PATH,
                'suspension': SUSPENSION_MODEL_PATH
            };

            const onModelLoaded = (gltf, modelName) => {
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        const material = child.material;
                        
                        material.transparent = false;
                        material.opacity = 1.0;
                        material.emissive.set(0x000000);
                        material.emissiveIntensity = 0.0;
                        material.needsUpdate = true;
                        
                        // --- MATERIAL CUSTOMIZATION (FINAL TRANSLUCENCY TWEAKS) ---
                        let metalness = 0.0;
                        let roughness = 0.5;
                        let color = 0xffffff;

                        if (modelName === 'sink') {
                            // ALUMINA HEATSINK: Pure White, low sheen
                            metalness = 0.01; roughness = 0.4; color = 0xffffff; 
                        } else if (modelName === 'shade') {
                            // REFINED: DIFFUSE TRANSLUCENT PORCELAIN SHADE
                            metalness = 0.01; 
                            roughness = 0.95; 
                            color = 0xffffff; 
                            material.transparent = true; 
                            // *** LOWER OPACITY: Reduced to allow more light through ***
                            material.opacity = 0.6; 
                            material.side = THREE.DoubleSide; // Render both sides of the shade for better lighting
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS
                            metalness = 0.1; roughness = 0.1; color = 0xffffff; 
                            material.emissive.set(0xffeebb); 
                            // *** BOOSTED INTENSITY: Max power for the internal light source ***
                            material.emissiveIntensity = 10.0; 
                        } else if (modelName === 'gripper') {
                            // SATIN ALUMINUM METAL
                            metalness = 0.9; roughness = 0.5; color = 0xc0c0c0;
                        } else if (modelName === 'holder' || modelName === 'bands') {
                            // MATTE PLASTIC WHITE 
                            metalness = 0.0; roughness = 0.8; color = 0xffffff; 
                        } else if (modelName === 'suspension') {
                            // DARKER GREY METAL WIRE CABLE
                            metalness = 0.9; roughness = 0.2; color = 0x444444; 
                        } else if (modelName === 'feeds') {
                            // SLIGHTLY TRANSLUCENT DIFFUSE RUBBER (LIGHTER GRAY)
                            metalness = 0.0; roughness = 0.8; color = 0x666666; 
                            material.transparent = true; material.opacity = 0.9; 
                        }

                        material.metalness = metalness;
                        material.roughness = roughness;
                        material.color.set(color); 
                        // --- END MATERIAL CUSTOMIZATION ---
                    }
                });

                models[modelName] = loadedModel;
                
                // --- POSITIONING LOGIC ---
                const defaultScale = 1.0; 
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(defaultScale, defaultScale, defaultScale);
                
                scene.add(loadedModel);
                modelsLoaded++;

                if (modelsLoaded === totalModels) {
                    console.log("Assembly and Materials complete. Ready for final review.");
                }
            };
            
            // Loop through all paths to load models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    undefined, 
                    (error) => {
                        console.error(`Error loading ${modelName}:`, error);
                    }
                );
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls && controls.enableDamping) controls.update(); 
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>