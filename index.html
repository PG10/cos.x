<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>LED Fixture Model - Local Three.js Setup</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
    #loading {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 1000;
    }
    #controls {
      position: fixed;
      top: 20px; right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      z-index: 1000;
    }
    #controls label { display: block; margin: 5px 0; }
    #controls input[type="range"] { width: 150px; margin-left: 10px; }
  </style>
</head>
<body>
  <div id="loading">Loading LED Fixture...</div>
  <div id="controls" style="display: none;">
    <label>Bloom Strength: <input type="range" id="bloomStrength" min="0" max="10" step="0.1" value="1.2"></label>
    <label>Emission Power: <input type="range" id="emissionIntensity" min="0" max="50" step="1" value="10"></label>
    <label>Exposure: <input type="range" id="exposure" min="0" max="3" step="0.1" value="1.2"></label>
  </div>

  <script type="module">
    import * as THREE from './js/three.module.js';
    import { OrbitControls } from './js/addons/controls/OrbitControls.js';
    import { GLTFLoader } from './js/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from './js/addons/loaders/DRACOLoader.js';
    import { RGBELoader } from './js/addons/loaders/RGBELoader.js';
    import { EffectComposer } from './js/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from './js/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from './js/addons/postprocessing/UnrealBloomPass.js';

    // --- CONFIG ---
    const CONFIG = {
      TONE_MAPPING_EXPOSURE: 1.2,
      CERAMIC_COLOR: 0xe8e8e8,
      METAL_COLOR: 0x444444,
      LENS_EMISSIVE_COLOR: 0xfff2e0,
      SHADE_BASE_COLOR: 0xffffff,
      CERAMIC_ROUGHNESS: 0.9,
      SHADE_TRANSMISSION: 0.9,
      LENS_EMISSIVE_INTENSITY: 10.0,
      SHADE_EMISSIVE_INTENSITY: 0.05,
      BLOOM_STRENGTH: 1.2,
      BLOOM_RADIUS: 0.6,
      BLOOM_THRESHOLD: 0.8
    };

    let scene, camera, renderer, composer, controls;
    let lensObjects = [];
    let modelsLoaded = 0;

    init();

    function init() {
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = CONFIG.TONE_MAPPING_EXPOSURE;
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // Scene + Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.5, 3);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Environment map
      const rgbeLoader = new RGBELoader();
      rgbeLoader.load('./textures/env.hdr', (texture) => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture;
      });

      // Postprocessing
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        CONFIG.BLOOM_STRENGTH,
        CONFIG.BLOOM_RADIUS,
        CONFIG.BLOOM_THRESHOLD
      );
      composer.addPass(bloomPass);

      // Draco + GLTF Loader
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('./draco/');
      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);

      // Models to load
      const modelPaths = {
        shade: './models/shade.glb',
        lens: './models/lens.glb',
        holder: './models/holder.glb',
        bands: './models/bands.glb',
        feeds: './models/feeds.glb',
        gripper: './models/gripper.glb',
        suspension: './models/suspension.glb',
        sink: './models/sink.glb'
      };

      const totalModels = Object.keys(modelPaths).length;

      // Load function with materials
      function loadPart(path, onMesh) {
        loader.load(path, (gltf) => {
          const obj = gltf.scene;
          obj.traverse((child) => {
            if (child.isMesh) onMesh(child);
          });
          scene.add(obj);

          modelsLoaded++;
          document.getElementById('loading').textContent =
            `Loading models... ${modelsLoaded}/${totalModels}`;
          if (modelsLoaded === totalModels) {
            document.getElementById('loading').style.display = 'none';
          }
        });
      }

      // === Load each part ===
      loadPart(modelPaths.shade, (mesh) => {
        mesh.material = new THREE.MeshPhysicalMaterial({
          color: CONFIG.SHADE_BASE_COLOR,
          roughness: CONFIG.CERAMIC_ROUGHNESS,
          transmission: CONFIG.SHADE_TRANSMISSION,
          thickness: 2.0,
          emissive: new THREE.Color(0xffd8b0),
          emissiveIntensity: CONFIG.SHADE_EMISSIVE_INTENSITY
        });
      });

      loadPart(modelPaths.lens, (mesh) => {
        mesh.material = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          roughness: 0.3,
          emissive: new THREE.Color(CONFIG.LENS_EMISSIVE_COLOR),
          emissiveIntensity: CONFIG.LENS_EMISSIVE_INTENSITY
        });
        lensObjects.push(mesh);
      });

      loadPart(modelPaths.holder, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: CONFIG.CERAMIC_COLOR,
          roughness: CONFIG.CERAMIC_ROUGHNESS,
          metalness: 0.0
        });
      });

      loadPart(modelPaths.bands, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: CONFIG.CERAMIC_COLOR,
          roughness: CONFIG.CERAMIC_ROUGHNESS,
          metalness: 0.1
        });
      });

      loadPart(modelPaths.feeds, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: CONFIG.CERAMIC_COLOR,
          roughness: CONFIG.CERAMIC_ROUGHNESS,
          metalness: 0.0
        });
      });

      loadPart(modelPaths.gripper, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: CONFIG.METAL_COLOR,
          roughness: 0.4,
          metalness: 1.0
        });
      });

      loadPart(modelPaths.suspension, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: 0x222222,
          roughness: 0.7,
          metalness: 0.3
        });
      });

      loadPart(modelPaths.sink, (mesh) => {
        mesh.material = new THREE.MeshStandardMaterial({
          color: CONFIG.METAL_COLOR,
          roughness: 0.6,
          metalness: 0.8
        });
      });

      // Light
      const bulb = new THREE.PointLight(0xffd8b0, 50, 100);
      bulb.position.set(0, -0.5, 0);
      scene.add(bulb);

      // UI Controls
      document.getElementById('controls').style.display = 'block';
      setupUI(bloomPass);

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function setupUI(bloomPass) {
      document.getElementById('bloomStrength').addEventListener('input', e => {
        bloomPass.strength = parseFloat(e.target.value);
      });
      document.getElementById('emissionIntensity').addEventListener('input', e => {
        CONFIG.LENS_EMISSIVE_INTENSITY = parseFloat(e.target.value);
        lensObjects.forEach(lens => lens.material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY);
      });
      document.getElementById('exposure').addEventListener('input', e => {
        renderer.toneMappingExposure = parseFloat(e.target.value);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      composer.render();
    }
  </script>
</body>
</html>
