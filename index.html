<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Photorealistic White Studio</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- 
        Standard Three.js Libraries using CDN links (r128) 
    -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <!-- Standard Example Loaders (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- POST-PROCESSING PASSES (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script> 
    
    <!-- SHADER FILES REQUIRED FOR THE COMPOSER CHAIN (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    
    <script>
        // --- FILE PATHS ---
        const BANDS_MODEL_PATH      = './bands.glb';
        const FEEDS_MODEL_PATH      = './feeds.glb';
        const GRIPPER_MODEL_PATH    = './gripper.glb';
        const HOLDER_MODEL_PATH     = './holder.glb';
        const LENS_MODEL_PATH       = './lens.glb';
        const SHADE_MODEL_PATH      = './shade.glb';
        const SINK_MODEL_PATH       = './sink.glb';    
        const SUSPENSION_MODEL_PATH = './suspension.glb';
        
        let scene, camera, renderer, controls;
        let bloomComposer, finalComposer;
        
        // --- SELECTIVE BLOOM SETUP ---
        const ENTIRE_SCENE = 0;
        const BLOOM_SCENE = 1;

        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        const materials = {};
        const darkMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
        // ------------------------------
        
        function init() {
            const INITIAL_CAMERA_Z = 50.0; 

            // 1. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Set exposure for photorealistic brightness
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = 0.4; 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            // Set background to light gray for subtle contrast
            renderer.setClearColor(0xeeeeee); 
            document.body.appendChild(renderer.domElement);

            // 2. Setup Scene and Camera
            scene = new THREE.Scene();
            
            // 3. Lighting Setup (Studio Lighting Approach)
            
            // Main Fill Light (Bright Ambient) - provides overall softness
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
            scene.add(ambientLight);

            // Key Light (Subtle directional light to define shape and cast soft shadows)
            const keyLight = new THREE.DirectionalLight(0xffeebb, 0.8);
            keyLight.position.set(20, 30, 40); // Top-front angle
            scene.add(keyLight);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0.0, 10.0, INITIAL_CAMERA_Z); 
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.enableDamping = true;
            controls.update();
            
            // 4. Setup Composers (Bloom Effect)
            setupComposers();

            // 5. Load Assets
            loadHDRAndModels();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function setupComposers() {
            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,  // strength (increased to match high lens brightness)
                0.3,  // radius 
                0.85   // threshold 
            );

            bloomComposer = new THREE.EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(renderScene);
            bloomComposer.addPass(bloomPass);

            const finalPass = new THREE.ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: null },
                        bloomTexture: { value: bloomComposer.renderTarget2.texture } 
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D baseTexture;
                        uniform sampler2D bloomTexture;
                        varying vec2 vUv;
                        void main() {
                            vec4 baseColor = texture2D( baseTexture, vUv );
                            vec4 bloomColor = texture2D( bloomTexture, vUv );
                            // Combine base scene and bloom, reducing bloom factor slightly
                            gl_FragColor = baseColor + (bloomColor * 0.8); 
                        }
                    `,
                    defines: {}
                }), "baseTexture"
            );
            finalPass.needsSwap = true;

            finalComposer = new THREE.EffectComposer(renderer);
            finalComposer.addPass(renderScene);
            finalComposer.addPass(finalPass);
        }

        function loadHDRAndModels() {
            // No HDR environment map needed for this studio setup (it complicates white-on-white)
            loadAllModels();
            /*
            new THREE.RGBELoader()
                .setPath('./') 
                .load('env.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; 
                    renderer.autoClear = false; 
                    scene.environmentIntensity = 0.1; 
                    loadAllModels();
                },
                undefined, 
                (error) => console.error("Could not load 'env.hdr'. Proceeding without environment map.", error)
            );
            */
        }

        function loadAllModels() {
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('./draco/'); 
            
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            const modelPaths = {
                'sink': SINK_MODEL_PATH, 'shade': SHADE_MODEL_PATH, 'bands': BANDS_MODEL_PATH, 
                'feeds': FEEDS_MODEL_PATH, 'gripper': GRIPPER_MODEL_PATH, 'holder': HOLDER_MODEL_PATH, 
                'lens': LENS_MODEL_PATH, 'suspension': SUSPENSION_MODEL_PATH
            };

            const isCeramicPart = (name) => 
                name === 'sink' || name === 'holder' || name === 'bands' || name === 'feeds';
            
            const onModelLoaded = (gltf, modelName) => {
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        
                        let material = child.material;
                        
                        // Force MeshPhysicalMaterial for maximum control over PBR properties
                        if (!material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshPhysicalMaterial().copy(material);
                            child.material = material;
                        }

                        // --- APPLY FINAL PBR AND GLOW PROPERTIES ---
                        material.emissive.set(0x000000); 
                        child.layers.set(ENTIRE_SCENE); 
                        
                        // Define the base color for white parts (slight off-white)
                        const CERAMIC_COLOR = 0xf5f5f5; 

                        if (modelName === 'shade') {
                            // TRANSLUCENT SHADE: Matte Translucency with a hint of warm color
                            material.transmission = 0.85; 
                            material.thickness = 1.0; 
                            material.transparent = true;
                            material.side = THREE.DoubleSide; 
                            material.roughness = 0.95; 
                            material.metalness = 0.0;
                            // Give the shade a soft, warm tint
                            material.color.set(0xfff8f0); 
                            
                            // SHADE GLOW (Passive emission to enhance diffusion)
                            material.emissive.set(0xffeebb);
                            material.emissiveIntensity = 0.1; 
                            child.layers.enable(BLOOM_SCENE); 
                            
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS (The primary light source)
                            material.metalness = 0.0; material.roughness = 0.0; // Minimal roughness
                            material.color.set(0xffffff);
                            material.emissive.set(0xffeebb); 
                            // HIGH Emissive intensity for maximum bloom and light spill
                            material.emissiveIntensity = 40.0; 
                            child.layers.enable(BLOOM_SCENE); 

                        } else if (isCeramicPart(modelName)) {
                            // CERAMIC PARTS (Matte Off-White)
                            material.metalness = 0.0; 
                            material.roughness = 1.0; // Max roughness (pure matte)
                            material.color.set(CERAMIC_COLOR); // Off-white for contrast
                            
                        } else if (modelName === 'gripper' || modelName === 'suspension') {
                            // METAL PARTS (Dark Gray Chrome)
                            material.metalness = 0.9; 
                            material.roughness = 0.5; 
                            material.color.set(0x444444); 
                        }
                        
                        child.material.needsUpdate = true;
                        // --- END MATERIAL CUSTOMIZATION ---
                    }
                });
                
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(1.0, 1.0, 1.0);
                scene.add(loadedModel);
            };
            
            // Load all models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    undefined, 
                    (error) => console.error(`Error loading ${modelName}:`, error)
                );
            });
        }
        
        // --- SELECTIVE BLOOM RENDER UTILITIES ---
        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }
        // ---------------------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomComposer.setSize(window.innerWidth, window.innerHeight); 
            finalComposer.setSize(window.innerWidth, window.innerHeight); 
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); 
            
            // 1. Render the scene, but make all non-glowing objects black
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();

            // 2. Restore all original materials
            scene.traverse(restoreMaterial);
            
            // 3. Render the final combined scene (original objects + bloom)
            finalComposer.render();
        }

        init();
    </script>
</body>
</html>
