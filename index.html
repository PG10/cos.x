<!DOCTYPE html>
<html>
<head>
    <title>LED Fixture Model - Self-Illuminated Glow</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- 
        Standard Three.js Libraries using CDN links (r128) 
    -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <!-- Standard Example Loaders (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- 
        POST-PROCESSING PASSES (UMD versions from CDN) 
        NOTE: These must load BEFORE the main script attempts to use their constructors (RenderPass, EffectComposer, etc.).
    -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script> 
    
    <!-- SHADER FILES REQUIRED FOR THE COMPOSER CHAIN (UMD versions from CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    
    <script>
        // --- SCENE CONFIGURATION PARAMETERS ---
        const CONFIG = {
            // RENDERER & ENVIRONMENT
            TONE_MAPPING_EXPOSURE: 1.0,          // Adjusted exposure for a balanced look (1.0 is standard)
            BACKGROUND_COLOR: 0x111111,          // KEY CHANGE: Dark background to create contrast for white objects
            HDR_ENVIRONMENT_INTENSITY: 0.7,      // Strength of the loaded 'env.hdr' map
            
            // MATERIAL COLORS
            CERAMIC_COLOR: 0xe8e8e8,             // Base color for sink, holder, etc.
            METAL_COLOR: 0x444444,               // Color for gripper and suspension (Dark Gray)
            LENS_EMISSIVE_COLOR: 0xffd8b0,       // Warm color for the light source
            SHADE_BASE_COLOR: 0xffffff,          // Base color for the translucent shade
            
            // MATERIAL PROPERTIES
            CERAMIC_ROUGHNESS: 1.0,              // Full roughness (matte look)
            SHADE_TRANSMISSION: 0.9,             // High transmission (translucent)
            
            // LIGHT EMISSION INTENSITIES
            LENS_EMISSIVE_INTENSITY: 40.0,       // Light source is now on (moderate intensity)
            SHADE_EMISSIVE_INTENSITY: 0.0,       // Shade relies on the lens for illumination
            
            // POST-PROCESSING (UNREAL BLOOM)
            BLOOM_STRENGTH: 5.0,                 // Increased bloom strength
            BLOOM_RADIUS: 0.5,                   // Spread of the glow effect
            BLOOM_THRESHOLD: 0.9                 // Only colors above this brightness will bloom
        };
        // --------------------------------------

        // --- FILE PATHS ---
        const BANDS_MODEL_PATH      = './bands.glb';
        const FEEDS_MODEL_PATH      = './feeds.glb';
        const GRIPPER_MODEL_PATH    = './gripper.glb';
        const HOLDER_MODEL_PATH     = './holder.glb';
        const LENS_MODEL_PATH       = './lens.glb';
        const SHADE_MODEL_PATH      = './shade.glb';
        const SINK_MODEL_PATH       = './sink.glb';    
        const SUSPENSION_MODEL_PATH = './suspension.glb';
        
        let scene, camera, renderer, controls;
        let bloomComposer, finalComposer;
        
        // --- SELECTIVE BLOOM SETUP ---
        const ENTIRE_SCENE = 0;
        const BLOOM_SCENE = 1;

        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        const materials = {};
        const darkMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
        // ------------------------------
        
        function init() {
            const INITIAL_CAMERA_Z = 50.0; 

            // 1. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = CONFIG.TONE_MAPPING_EXPOSURE; 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            renderer.setClearColor(CONFIG.BACKGROUND_COLOR); 
            document.body.appendChild(renderer.domElement);

            // 2. Setup Scene and Camera
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0.0, 10.0, INITIAL_CAMERA_Z); 
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); 
            controls.enableDamping = true;
            controls.update();
            
            // 4. Setup Composers (Bloom Effect)
            setupComposers();

            // 5. Load Assets
            loadHDRAndModels();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function setupComposers() {
            // NOTE: RenderPass, UnrealBloomPass, EffectComposer, and ShaderPass are globally available 
            // because they were loaded by <script> tags, so we use them without the 'THREE.' prefix.
            
            const renderScene = new RenderPass(scene, camera);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.BLOOM_STRENGTH, 
                CONFIG.BLOOM_RADIUS, 
                CONFIG.BLOOM_THRESHOLD
            );

            bloomComposer = new EffectComposer(renderer);
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass(renderScene);
            bloomComposer.addPass(bloomPass);

            const finalPass = new ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: { value: null },
                        bloomTexture: { value: bloomComposer.renderTarget2.texture } 
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D baseTexture;
                        uniform sampler2D bloomTexture;
                        varying vec2 vUv;
                        void main() {
                            vec4 baseColor = texture2D( baseTexture, vUv );
                            vec4 bloomColor = texture2D( bloomTexture, vUv );
                            gl_FragColor = baseColor + (bloomColor * 0.9); 
                        }
                    `,
                    defines: {}
                }), "baseTexture"
            );
            finalPass.needsSwap = true;

            finalComposer = new EffectComposer(renderer);
            finalComposer.addPass(renderScene);
            finalComposer.addPass(finalPass);
        }

        function loadHDRAndModels() {
            // Loading HDR texture to provide scene lighting/environment map
            new THREE.RGBELoader()
                .setPath('./') 
                .load('env.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture; 
                    renderer.autoClear = false; 
                    scene.environmentIntensity = CONFIG.HDR_ENVIRONMENT_INTENSITY; 
                    loadAllModels();
                },
                undefined, 
                (error) => {
                     console.error("FATAL ERROR: Could not load 'env.hdr'. Proceeding without environment map.", error);
                     // Fallback in case HDR fails to load
                     loadAllModels();
                }
            );
        }

        function loadAllModels() {
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('./draco/'); 
            
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            const modelPaths = {
                'sink': SINK_MODEL_PATH, 'shade': SHADE_MODEL_PATH, 'bands': BANDS_MODEL_PATH, 
                'feeds': FEEDS_MODEL_PATH, 'gripper': GRIPPER_MODEL_PATH, 'holder': HOLDER_MODEL_PATH, 
                'lens': LENS_MODEL_PATH, 'suspension': SUSPENSION_MODEL_PATH
            };

            const isCeramicPart = (name) => 
                name === 'sink' || name === 'holder' || name === 'bands' || name === 'feeds';
            
            const onModelLoaded = (gltf, modelName) => {
                const loadedModel = gltf.scene;
                
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        
                        let material = child.material;
                        
                        // Ensure material is MeshPhysicalMaterial for PBR and transmission
                        if (!material.isMeshPhysicalMaterial) {
                            material = new THREE.MeshPhysicalMaterial().copy(material);
                            child.material = material;
                        }

                        // --- APPLY FINAL PBR AND GLOW PROPERTIES ---
                        material.emissive.set(0x000000); 
                        child.layers.set(ENTIRE_SCENE); 
                        
                        if (modelName === 'shade') {
                            // TRANSLUCENT SHADE
                            material.transmission = CONFIG.SHADE_TRANSMISSION; 
                            material.thickness = 1.0; 
                            material.transparent = true;
                            material.side = THREE.DoubleSide; 
                            material.roughness = 0.9; 
                            material.metalness = 0.0;
                            material.color.set(CONFIG.SHADE_BASE_COLOR); 
                            
                            material.emissive.set(0x000000); 
                            material.emissiveIntensity = CONFIG.SHADE_EMISSIVE_INTENSITY; 
                            child.layers.enable(BLOOM_SCENE); 
                            
                        } else if (modelName === 'lens') {
                            // WARM EMISSIVE LENS: The primary light source
                            material.metalness = 0.0; material.roughness = 0.0;
                            material.color.set(0xffffff);
                            material.emissive.set(CONFIG.LENS_EMISSIVE_COLOR); 
                            material.emissiveIntensity = CONFIG.LENS_EMISSIVE_INTENSITY; 
                            child.layers.enable(BLOOM_SCENE); // Mark for bloom

                        } else if (isCeramicPart(modelName)) {
                            // CERAMIC PARTS
                            material.metalness = 0.0; 
                            material.roughness = CONFIG.CERAMIC_ROUGHNESS; 
                            material.color.set(CONFIG.CERAMIC_COLOR); 
                            
                        } else if (modelName === 'gripper' || modelName === 'suspension') {
                            // METAL PARTS
                            material.metalness = 0.9; 
                            material.roughness = 0.5; 
                            material.color.set(CONFIG.METAL_COLOR); 
                        }
                        
                        child.material.needsUpdate = true;
                    }
                });
                
                loadedModel.position.set(0, 0, 0); 
                loadedModel.scale.set(1.0, 1.0, 1.0);
                scene.add(loadedModel);
            };
            
            // Load all models
            Object.keys(modelPaths).forEach(modelName => {
                gltfLoader.load(modelPaths[modelName], 
                    (gltf) => onModelLoaded(gltf, modelName), 
                    undefined, 
                    (error) => console.error(`Error loading ${modelName}:`, error)
                );
            });
        }
        
        // --- SELECTIVE BLOOM RENDER UTILITIES ---
        function darkenNonBloomed(obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }
        // ---------------------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomComposer.setSize(window.innerWidth, window.innerHeight); 
            finalComposer.setSize(window.innerWidth, window.innerHeight); 
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); 
            
            // 1. Render the scene, but make all non-glowing objects black
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();

            // 2. Restore all original materials
            scene.traverse(restoreMaterial);
            
            // 3. Render the final combined scene (original objects + bloom)
            finalComposer.render();
        }

        // FIX: Ensure 'init' runs only after all external scripts (like RenderPass.js) are loaded.
        window.onload = init;

    </script>
</body>
</html>
